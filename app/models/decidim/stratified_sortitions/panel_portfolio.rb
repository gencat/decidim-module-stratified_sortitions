# frozen_string_literal: true

module Decidim
  module StratifiedSortitions
    # Stores the portfolio of panels generated by the LEXIMIN algorithm.
    #
    # This model enables a two-phase sortition process:
    # 1. Generate portfolio (expensive computation, stores panels and probabilities)
    # 2. Sample from portfolio (fast, selects one panel according to distribution)
    #
    # The separation allows for:
    # - Background generation of portfolios
    # - Public/auditable sampling ceremonies
    # - Verification of results using the stored data
    #
    # @example Generate and sample
    #   portfolio = PanelPortfolio.create!(
    #     stratified_sortition: sortition,
    #     panels: [[1, 2, 3], [4, 5, 6]],
    #     probabilities: [0.6, 0.4],
    #     generated_at: Time.current
    #   )
    #
    #   # Later, sample from the portfolio
    #   portfolio.sample!(verification_seed: "public_seed")
    #   portfolio.selected_panel # => [1, 2, 3] or [4, 5, 6]
    #
    class PanelPortfolio < ApplicationRecord
      self.table_name = "decidim_stratified_sortitions_panel_portfolios"

      belongs_to :stratified_sortition,
                 class_name: "Decidim::StratifiedSortitions::StratifiedSortition",
                 foreign_key: "decidim_stratified_sortitions_stratified_sortition_id"

      validates :panels, presence: true
      validates :probabilities, presence: true
      validates :generated_at, presence: true
      validate :panels_and_probabilities_match
      validate :probabilities_sum_to_one

      # Check if the portfolio has been sampled
      #
      # @return [Boolean]
      def sampled?
        selected_panel_index.present?
      end

      # Get the selected panel (after sampling)
      #
      # @return [Array<Integer>, nil] Array of participant IDs or nil if not sampled
      def selected_panel
        return nil unless sampled?

        panels[selected_panel_index]
      end

      # Get the probability of the selected panel
      #
      # @return [Float, nil]
      def selected_panel_probability
        return nil unless sampled?

        probabilities[selected_panel_index]
      end

      # Sample a panel from this portfolio
      #
      # @param verification_seed [String, nil] Optional seed for reproducible sampling
      # @return [Leximin::PanelSampler::Result]
      # @raise [RuntimeError] if already sampled
      def sample!(verification_seed: nil)
        raise "Portfolio already sampled" if sampled?

        random_seed = derive_random_seed(verification_seed)
        sampler = Leximin::PanelSampler.new(panels, probabilities, random_seed:)
        result = sampler.sample

        if result.success?
          update!(
            selected_panel_index: result.selected_index,
            selected_at: Time.current,
            verification_seed:,
            random_value_used: result.random_value
          )
        end

        result
      end

      # Load selected participants from database
      #
      # @return [Array<SampleParticipant>]
      def selected_participants
        return [] unless sampled?

        SampleParticipant.where(id: selected_panel).order(:id).to_a
      end

      # Number of panels in the portfolio
      #
      # @return [Integer]
      def num_panels
        panels&.size || 0
      end

      # Fairness metrics for this portfolio
      #
      # @return [Hash]
      def fairness_metrics
        probs = selection_probabilities.values
        return {} if probs.empty?

        {
          min_probability: probs.min,
          max_probability: probs.max,
          mean_probability: probs.sum / probs.size,
          probability_range: probs.max - probs.min,
        }
      end

      # Build audit log for the portfolio
      #
      # @return [Hash]
      def audit_log
        {
          algorithm: "LEXIMIN",
          version: "1.0",
          stratified_sortition_id:,
          generated_at: generated_at&.iso8601,
          generation_time_seconds:,
          num_panels:,
          num_iterations:,
          convergence_achieved:,
          sampled: sampled?,
          selected_at: selected_at&.iso8601,
          selected_panel_index:,
          verification_seed:,
          random_value_used:,
          selected_panel_probability:,
          fairness_metrics:,
        }
      end

      private

      def derive_random_seed(seed)
        return nil unless seed

        Digest::SHA256.hexdigest(seed).to_i(16) % (2**31)
      end

      def panels_and_probabilities_match
        return if panels.blank? || probabilities.blank?
        return if panels.size == probabilities.size

        errors.add(:probabilities, "must have the same size as panels (#{panels.size} panels, #{probabilities.size} probabilities)")
      end

      def probabilities_sum_to_one
        return if probabilities.blank?

        total = probabilities.sum
        return if (total - 1.0).abs < 0.001

        errors.add(:probabilities, "must sum to 1.0 (currently #{total})")
      end
    end
  end
end
